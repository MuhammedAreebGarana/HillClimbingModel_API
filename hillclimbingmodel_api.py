# -*- coding: utf-8 -*-
"""HillClimbingModel_API.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v6kUl-cXU9LmTpgZi1A2mXc5vHIQ56Tn

We are trying to optimize (minimize) memory usage of an API by tweaking its configuration parameters. These parameters include:

**batch_size**: How much data is processed at once

**cache_ttl**: How long responses are cached

**thread_pool_size**: Number of concurrent threads handling requests

**compression_enabled**: Whether compression is used (saves memory, but adds CPU cost)

Each configuration leads to different memory usage. The model tries to find the best one.
"""

!pip install psutil

"""This model uses hill climbing search to find the best API configuration that minimizes memory usage.

Start with a random configuration (e.g., batch size, cache time, thread count, compression).

Use a trained regression model (like Random Forest) to predict memory usage for each configuration.

Generate "neighboring" configurations by changing one parameter at a time.

Pick the neighbor with the lowest predicted memory usage.

Repeat the process until no better configuration is found.

The result is an optimized configuration that uses the least memory based on real or simulated data â€” all without testing every possible combination. **bold text**
"""

import pandas as pd
from sklearn.ensemble import RandomForestRegressor
import random

# Dataset
data = pd.DataFrame([
    {'batch_size': 16, 'cache_ttl': 60, 'thread_pool_size': 2, 'compression_enabled': True, 'memory_usage_MB': 120},
    {'batch_size': 32, 'cache_ttl': 60, 'thread_pool_size': 2, 'compression_enabled': True, 'memory_usage_MB': 135},
    {'batch_size': 32, 'cache_ttl': 300, 'thread_pool_size': 4, 'compression_enabled': False, 'memory_usage_MB': 190},
    {'batch_size': 64, 'cache_ttl': 600, 'thread_pool_size': 8, 'compression_enabled': False, 'memory_usage_MB': 280},
    {'batch_size': 128, 'cache_ttl': 600, 'thread_pool_size': 16, 'compression_enabled': False, 'memory_usage_MB': 400},
    {'batch_size': 64, 'cache_ttl': 300, 'thread_pool_size': 4, 'compression_enabled': True, 'memory_usage_MB': 210},
])

# Feature encoding
X = data.drop(columns='memory_usage_MB')
X['compression_enabled'] = X['compression_enabled'].astype(int)  # Boolean to int
y = data['memory_usage_MB']

# Train model
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X, y)

# Parameter space
param_space = {
    'batch_size': [16, 32, 64, 128],
    'cache_ttl': [60, 300, 600],
    'thread_pool_size': [2, 4, 8, 16],
    'compression_enabled': [True, False]
}

def predict_memory(config):
    df = pd.DataFrame([config])
    df['compression_enabled'] = df['compression_enabled'].astype(int)
    return model.predict(df)[0]

def get_neighbors(config):
    neighbors = []
    for key in config:
        index = param_space[key].index(config[key])
        if index > 0:
            new_config = config.copy()
            new_config[key] = param_space[key][index - 1]
            neighbors.append(new_config)
        if index < len(param_space[key]) - 1:
            new_config = config.copy()
            new_config[key] = param_space[key][index + 1]
            neighbors.append(new_config)
    return neighbors

def hill_climb(initial_config):
    current_config = initial_config
    current_score = predict_memory(current_config)
    history = [(current_config, current_score)]

    while True:
        neighbors = get_neighbors(current_config)
        improved = False
        for neighbor in neighbors:
            score = predict_memory(neighbor)
            if score < current_score:
                current_config = neighbor
                current_score = score
                history.append((current_config, current_score))
                improved = True
                break
        if not improved:
            break
    return current_config, current_score, history

# Random start
initial_config = {k: random.choice(v) for k, v in param_space.items()}
best_config, best_score, history = hill_climb(initial_config)

# Output
print("Initial config:", initial_config)
print("Best config:", best_config)
print("Predicted memory usage (MB):", round(best_score, 2))

import matplotlib.pyplot as plt

scores = [score for _, score in history]
plt.plot(scores, marker='o')
plt.title("Hill Climbing Optimization")
plt.xlabel("Iteration")
plt.ylabel("Predicted Memory Usage (MB)")
plt.grid(True)
plt.show()